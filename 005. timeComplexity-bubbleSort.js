👉 
// Bubble sort는 컴퓨터 과학의 가장 기본적인 알고리즘입니다.
// 배열의 첫 번째 요소(element)와 두 번째 요소를 비교함으로써 시작합니다. 
// 첫 번째 요소가 두 번째 요소보다 크면, 두 요소의 위치를 바꿉니다. 
// (swap) 이후 두 번째 요소와 세 번째 요소를 비교하고, 이를 마지막까지 반복합니다. 
// 위와 같은 방식을 통해서 가장 큰 요소가 가장 마지막으로 밀려납니다. 
// 이 모습이 마치 "거품이 밀려 올라가는 것과 같은 모습" 이여서 Bubble sort라 합니다. 
// 가장 큰 요소가 마지막으로 밀려간 후에는, 다시 첫 요소부터 지금까지의 정렬을 배열의 모든 요소가 크기 순서대로 정렬될 때까지 반복됩니다.

// Bubble sort 방식으로 배열을 인자로 받아 크기 순서대로 정렬된 배열을 반환하는 함수를 만드세요. 자바스크립트의 내장 함수 (Array.prototype.sort)는 사용을 금지합니다.

// 질문: 여러분이 작성한 알고리즘의 시간 복잡도는 어떻게 될까요? 
// 아직 잘 모르겠다면, 구글링보다는 직관적으로 얼마나 걸릴지 고민해보세요.

// i를 선언하여, 테스트를 원활하게 할 수 있습니다
// 헬퍼 함수가 필요하다면 얼마든지 만들어서 사용하세요!

👉 
// const bubbleSort = function(array) {
//   let swap;
//   for (let i = 0; i < array.length; i++) { // 순차적으로 비교하기 위한 반복문(순서가 정렬된 상태인지 확인)
//     for (let j = 0; j < array.length - 1 - i; j++) { // 끝까지 돌았을 때 다시 처음부터 비교하기 위한 반복문
                                                        // j는 j+1과 비교할 것이기 때문에 1을 빼주고(맨 마지막 요소가 겹치지 않도록),
//                                                      // 한번 순회할 때마다 마지막 요소는 확실히 정렬되므로 i를 빼준다
                                                        // 이 과정이 첫번째 for과 함께 계속 반복된다
                                                        // - 최종 정렬 될 때까지, 최종 정렬 된 것이 첫번째 for문에서 발견되면 더 이상 본 for문은 돌지 않는다
//       if (array[j] > array[j + 1]) { // 앞의 수와 뒤의 수를 비교해서 앞의 수가 크다면,
//         swap = array[j]; // 앞의 수를 변수에 할당
//         array[j] = array[j + 1]; // 뒤의 수를 앞의 수에 대입함으로써,
//         array[j + 1] = swap; // 뒤의 수를 변수에 재 할당(즉, 두 수의 위치 변경)
//       }
//     }
//     if (!swap) { // 첫번째 for문에서 순서가 정렬된 것이 발견되면
//       break;
//     }
//   }
//   return array;
// };

👉 
function bubbleSort(arr, length = arr.length) { 
  while (length) { // 결국 위와 같다, 한번 돌면서 
    for (let i = 0; i < arr.length -1; i++) { // -1 부분은 성능에 조금의 차이가 있을 수는 있으나, 필수적인 부분은 아니다
                                                // -i 부분은 length--;
      if (arr[i] > arr[i + 1]) {
        let swap = arr[i]; 
        arr[i] = arr[i + 1]; 
        arr[i + 1] = swap; 
      } // 각 회전을 끝내고 swap 변수가 undefined상태라면 정렬이 다 되어있다는 뜻이므로 바로 for문을 종료시킨다.
    }
  length--;
  }
  return arr;
};

👉 
// 코드를 보면 알 수 있듯이, for 문 안에 또 다시 for 문이 반복되는 nested for loop의 형태이기 때문에 O(n^2)이다.
  
// 버블 정렬은 최악의 경우에 O(n^2)의 시간 복잡도를 가진다. 
// 왜냐하면 각 자리를 찾기 위해서 n번의 순회를 해야하며, n번의 회전 동안에 요소의 개수만큼 또 순회를 해야하기 때문이다.
// 그러나 이미 정렬이 되어있는 경우에는 한 번의 순회로 정렬 여부를 알 수 있다.
  
// 0번 / 43215
// 1번 / 32145
// 2번 / 21345
// 3번 / 12345